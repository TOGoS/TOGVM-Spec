#+TITLE: TOGVM-Spec

Hello and welcome to TOGVM-Spec!

The project might be somewhat misnamed.
TOGVM is not a virtual machine
(though VMs could be, and to varying degrees have been built to evaluate the expressions it defines),
but a specification for a functional language whose programs can be described by RDF.

Why RDF?  Well, I like the idea of language-agnostic intermediate languages
with fully qualified names for the building blocks of a program
so that you can know exactly what one should do without having to ask
"Which compiler is used?  What options?  What libraries are provided?".
It also provides a simple escape hatch for adding extensions.
Invent whatever additional primitives you need for your own implementation.
Just make sure they're namespaced to avoid confusion.

This project also includes a meta-syntax for languages that compile to the RDF representation.
This is useful because people don't always want to write RDF+XML or JSON-LD directly.

This project consists of
[[./FUNCTIONS.json][a JSON file describing 'built-in' functions]],
[[./EXPRESSION-CLASSES.json][a JSON file describing expression classes]],
[[./RDF-VOCAB.tef][a TEF file indicating some other RDF types/attributes]],
and [[./test-vectors/][some test vectors]] (mostly about parsing based on the meta-language).

** Long names of expression attributes

Are not always spelled out in EXPRESSION-CLASSES.json.
They should be assumed to be "http://ns.nuke24.net/TOGVM/Expression/" + the short name
unless explicitly indicated otherwise by 'longName'.

** History

This project uses [[https://semver.org/][semantic versioning]].
Non-breaking versions may add new expression / function types,
or provide better definitions.

Major version number changes are breaking changes.
Names may be changed (e.g. 0.x -> 1.x renamed the entire 'Expression' namespace prefix),
or new fields added that an implementation must be aware of.
I may cheat and call conceptually breaking changes bugfix versions (x.x.+1)
if nobody is actually using the feature yet.

Obviously, for 'single meaning' to be true, even major version increases
should not change the meaning of existing names!

** Immutable, hash-identified functions

Closely-related to the concept of universal identifiers for intrinsic functioss is
that of universal identifiers for non-intrinsic functions.
This can be done easily by serializing the function and then referencing the hash.

This is the exact same idea [[https://www.unisonweb.org/][the Unison language]] ([[https://www.youtube.com/watch?v=gCWtkvDQ2ZI][introduction video]]) is based around
(I'm not sure who came up with the idea first
(I've been toying with the idea since about 2010 or possibly earlier),
but they have a nicer website than I do).

** Representatiosn of abstract concepts

Some concepts are natively represented by popular programming languages
and serialization formats (such as JSON):

- Strings
- Integers
- Floating-point numbers
- Lists

Some are slightly less universal;
specifically, JSON gives us some trouble:

- A byte array (JSON has no native representation!)
- A date
- A mapping of names to values (as distinct from an object with properties)
- A resource named by a URI (directly representable in RDF, but not in JSON)

Other concepts have no obvious universal representation that can be sent between programs:

- Your cousin Bob
- The result of some computation that we haven't yet done
- A directory tree
- A functional expression


As I see it, there are four primary ways to refer to values:
- Directly (atomic data types)
- By URI
- Describing with RDF
- Describing as the result of an expression

Depending on context, it may be more convenient to use one or the other of the above representations.
I would like to define conventions for converting between them.

In any context, there are things that can be described 'natively'.

e.g. in JavaScript, a JavaScript object stands for itself, and no encoding is necessary,
but if you want to talk about your cousin Bob, you need to add a layer of meaning
on top of what the language gives you in order to represent Bob in a program.
You could, for example, give Bob a URI like "urn:uuid:18b571ba-5268-4931-9ad4-002689a250b7"
(or, if you like using fake HTTP URLs as URNs in the RDF style, "http://ns.example.com/MyCousinBob"),
and then pass around objects of the form `{ "@id": "http://ns.example.com/MyCousinBob" }`.
You then need to, by convention, treat objects that consist of only an `"@id"` field as referring
to the named resource, rather than as 'plain old JavaScript objects'.

In RDF, on the other hand, resource-named-by-URI is a natively-supported concept.
On the other hand, RDF provides no formal way to represent JavaScript objects, and
if you want to refer to a JavaScript object in RDF, you'll have to come up with a way
to do so using the primitives that RDF does provide (maybe by indicating 'datatype = JSON' on a string).

#+BEGIN_QUOTE
How: RDF uses XMLâ€™s datatype mechanism, where data values are conveyed as a pair of items:
a lexical representation (a sequence of characters) and
a datatype identifier (a sequences of characters which happens to be a URI).
Each datatype is a mapping from strings (lexical representations) to values;
the datatype identifier tells us which datatype is to be used to interpret this particular representation.
#+END_QUOTE

That quote is from https://decentralyze.com/2010/06/04/from-json-to-rdf-in-six-easy-steps-with-jron/.
I think JSON-LD does the job this person was thinking of,
but the way they described the problem sort of matches how I think about it.
And I like that they made multiple-values-for-an-attribute the special case
instead of JSON-LD's approach of interpreting lists as multiple values and having to `{ "@list": [ ... ] }`
if you really want to represent the list itself.

*** TODO Document how to represent 'object indicated by a URI' in different contexts
*** TODO Document how to represent 'object described by this chunk of RDF' in different contexts
*** TODO Document how to represent 'object described by the result of a TOGVM expression' in different contexts
